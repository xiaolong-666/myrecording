# OSTree 介绍



## 类 Git 的可引导文件系统

首先，来看下 `libostree` 的官方定义：

> Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.

简而言之，`libostree` 是一个共享库和一组命令行工具，它结合了一种 “类似于Git” 的模型，用于提交和下载可引导的文件系统树，同时还提供了用于部署它们和管理引导加载程序配置的层次。

换句话说，`libostree` 用于管理可引导的操作系统生命周期，它采用了类似于 `Git` 版本控制系统的工作方式。与 `Git` 一样，`libostree` 使用校验和来管理文件，将操作系统的不同版本存储为一组不可变的对象。这些对象可以像源代码一样进行版本控制和回滚。这使得 `libostree` 能够轻松地管理不同版本的操作系统，并实现类似 `Git` 的分支、合并和回滚操作，为操作系统的生命周期管理提供了强大的工具。

然而，正如你所指出的，使用chroot创建不同“版本”的根文件系统可能会导致存储空间的浪费，因为相同的文件会重复出现。为了解决这个问题，需要一种方式来在不复制或共享文件的情况下，在不同的根文件夹中存储相同的文件，并能够跟踪版本更改。

## “有效地”复制文件系统

我们已经理解了使用chroot技术创建可引导的根文件系统环境，并希望实现类似Git的版本控制系统，以便有效管理不同版本的文件系统。现在让我们来谈谈如何实现“有效地”复制文件系统，这涉及到Linux中的硬链接。

在Linux中，有两种类型的文件链接：软链接（符号链接）和硬链接。软链接是一种特殊的文件，它指向另一个常规文件，而硬链接则是不同文件名直接指向相同数据和属性（inode）的文件。这两种链接类型之间有一个关键区别，使得硬链接更适合类似Git的版本控制用例。使用硬链接，即使你删除了“目标”文件，数据仍然可以访问，而软链接在目标文件被删除后将不再有效。在我们的情况下，我们需要在同一磁盘分区上拥有多个“文件副本”，并且这些副本必须是独立的，以防止删除一个文件影响到其他版本。

libostree使用硬链接来“checkout”文件，这意味着它可以在不复制文件内容的情况下创建多个文件系统版本，这是非常高效的。但这使得文件必须是不可变的，否则一个版本的更改将影响到其他版本。

为了解决这个问题，操作系统基于只读文件系统构建，并在启动时使用符号链接来选择可用的操作系统根文件系统“快照/镜像/部署”。每当你需要进行更改时，会创建一个全新的根文件系统的副本，但不需要复制所有文件内容，因此速度非常快。



`ostree` 最初是为了 GNOME Continuous 集成构建系统而开发的，但现在已经被广泛应用于许多 Linux 发行版中。以下是一些使用 `ostree` 的知名发行版：

1. Fedora CoreOS：Fedora CoreOS 是一个专门为容器化工作负载设计的操作系统，它基于 Fedora 发行版，并使用 `ostree` 来管理系统镜像和更新。
2. Silverblue：Fedora Silverblue 是 Fedora Workstation 的一个变体，采用了不可变系统镜像的概念，并使用 `ostree` 来实现原子更新。
3. Endless OS：Endless OS 是一个专门为教育和发展中国家设计的操作系统，它也使用了 `ostree` 来管理系统镜像和更新。
4. Flatpak：Flatpak 是一个用于打包、分发和运行应用程序的技术，它也使用了 `ostree` 来管理应用程序的运行时和运行环境。



底层架构可以概括为“操作系统二进制文件的 git”。它在用户空间中运行，并且可以在任何 Linux 文件系统之上运行。其核心是一个类似 git 的内容寻址对象存储，带有分支（或“引用”）来跟踪存储中有意义的文件系统树。同样，人们可以签出或提交这些分支。









## 那我们还需要包管理系统吗？

虽然libostree可以管理整个操作系统的更新和版本控制，但它并不完全替代了传统的软件包管理系统，因为它们在应用程序和库的管理方面有着不同的关注点和用途。

软件包管理系统（如APT、DNF等）主要用于管理单个软件包的安装、更新、卸载和依赖性解决。它们提供了更灵活的方式来安装和维护特定应用程序和库，允许用户选择性地安装和更新软件包，以满足其特定需求。软件包管理器还提供了易于使用的命令行工具和图形界面，用于搜索、安装和管理软件包。

与此不同，libostree专注于管理整个操作系统文件系统的版本和更新。它将整个文件系统作为一个不可变的对象来管理，以确保文件系统的一致性和可回滚性。这对于保持操作系统的稳定性和可靠性非常重要，特别是在大规模部署中。

因此，答案是，虽然libostree可以管理操作系统的更新和版本控制，但仍然需要传统的软件包管理系统来处理应用程序和库的安装和管理。这两者可以协同工作，为用户提供全面的软件管理解决方案，既可以管理整个操作系统，又可以管理个别软件包。在某些Linux发行版中，如RHEL for Edge和Fedora，已经有了特定于libostree的混合软件包管理器（如[rpm-ostree](https://coreos.github.io/rpm-ostree/)），以便更好地集成libostree和传统软件包管理系统的功能。

那么，libostree和rpm之间的这种协同工作是如何实现的呢？首先，DNF会将软件包安装到由libostree创建的文件系统中，这个文件系统是从原始部署复制而来的。然后，libostree将这个更新后的文件系统副本检入为一个新对象，并将其检出，以创建一个全新的操作系统版本。最后，通过重新启动操作系统，新的系统文件将得以生效，成为实际的“libostree部署的新版本”。简而言之，这个过程可以总结为以下步骤：

1. libostree检出原始文件系统的一个副本
2. DNF将软件包安装到此新文件系统副本中
3. libostree将此副本保存为新的对象
4. libostree将新对象检出，生成新的文件系统
5. 重新启动操作系统以应用新的系统文件

这种方式有效地结合了libostree的版本控制和不可变性特性以及传统软件包管理器（DNF）的能力，使得操作系统的更新和应用程序管理变得更加灵活和可管理。

## 参考链接

https://morven.life/posts/git-like-os-fs/

https://community.sap.com/t5/open-source-blogs/onboarding-to-the-garden-linux-team-getting-hands-dirty-with-ostree/ba-p/13575678